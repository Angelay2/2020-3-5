#include <stdio.h>
#include <Windows.h>
#include <assert.h>
#pragma warning(disable:4996)

// 1. 一个数组中只有2个数字是出现1次,其余所有数字都出现了2次
//    找出这2个值出现1次的数字, 编程实现

// 实现原理: (将所有的数字都异或 相同则为0 任何数与0异或都为它本身)
// 1 2 3 1 2 3 4  整体异或相当于组内的任意所有元素都相互异或(类似求和 => 求异或)
// 1^1^2^2^3^3^4    (1^6 = 6^1) 异或可以改变顺序(交换律)
//  0 ^ 0 ^ 0 ^4 (0^4 = 4  => 最后只剩下4)

// 第一步 将所有数据进行异或
// 1. 数组内元素的个数一定时偶数个
// 2. 如果整体异或, 最终结果一定是 那两个不同的数据异或的结果 
// 3. 所以, 因为两个数据一定不同, 所以最终结果一定不为 0,非0 
// 第二步 按比特位进行分组
// 4. 将最终结果看待成二进制 32个bit位一定至少有一个比特位是 1
// 5. 这个为 1 的位置异或之前的那两个不同数据 在该比特位的值一定不同(比如说倒数第三个比特位 0100)
// 6. 则我们可以采用 该位置原始两数的比特位 为0 还是为1 对原始数组分类 (分两类) 
// 第三步 转换成历史版本
// 7. 我们一定能将不同的(两个)数据分到不同的组 (只有0^1 才能产生 1)
// 8. 成对出现的两个相同数据一定会被分到同一组 (因为相同位置的比特位值都是相同的)
// 9. 最终所有数据被分为两组, 每一组中除了只有一个数字是单独外 其他都是成对的
 
// 代码:
// return value: 0 代表的是 success, other 代表的是 failed
// args(参数): a 代表的是输入数组, num代表的是元素的个数, 
//             xp/yp 代表的是输出型参数(通过该指针, 拿到对应的输出值(x,y) 就是两个只出现一次的数字)
int FindTwoData(int a[], int num, int* xp, int* yp){
	assert(a);
	assert(num >= 2); // 至少得有2个数据
	assert(xp);
	assert(yp);
	*xp = 0;
	*yp = 0;

	// 第一步
	int result = 1;
	int i = 1;
	for (; i < num; i++){
		result ^= a[i];
	}
	if (result == 0){
		return 1;// 返回值value: 0表示成功 非0表示错误, 所以我们return 1 => 题出错啦
	}
	// 最终result的值为两个不相同的数所异或的值

	// 第二步
	// 从右向左去找为第一个为1的比特位 8*sizeof(int) = 32 表示循环次数 
	// i 代表倒数第i+1位(从小到大 => 从右向左) 从i从0-31 也就是比特位从1-32
	i = 0;
	int flag = 1;// 1的31个比特位都为0 最后一个为1,
	// & 按位与时 全1为1
	// 首先用来检测result最低位 如果result&flag为真 则证明result最低位为1 
	// flag左移一位时 检测的就是次低位 左移几位就代表检测的是倒数第i+1位的元素
	// i = 0,表示flag不左移 就检测最低位
	while (i < 8 * sizeof(int)){
		if (result & (flag << i)){// 每次都应该从最低位左移 i 位
	//  if (result & (flag <<= 1)){// 这个是对的 每次都左移一位 

			break;// i = 0时, 检测了最低位; 后面依次检测其他的位 若为1 则找到了第一个为1的比特位
		}
		i++;// 若第一个不为1 ,则检测次低位 倒数第三位...
	}
	// 到这时, flag(只有一个比特位为1 其他都为0)就标识了不相同的那个比特位 
	flag <<= i;// 一个坑

	// 再用此时的 flag 去 &(全1才为1) 原始数组, 若有为 1 的
	// flag为 1 的那一位,那两个不相同的数据的在这个位 一定一个为0, 一个为1, 
	// 而其他的元素如果是成对出现的 必然&flag后 相同的位有相同的结果
	// 所以分类的两个组不影响判断两组中分别单独的那个数
	for (i = 0; i < num; i++){
		if (a[i] & flag){
		// 凡是进入这里的一定是那个除了一个数据单独外其余数据都是成对出现的数组
		// 将这个数组里 单独出现的那个数放在 xp 中
			*xp ^= a[i];// 最终所有的都异或时 只留下单独的数和0异或 然而任意数和0异或依然为其本身
		}
		else{
		// 凡是进入这里的也是除了一个数据单独出现外其余数据都是成对出现的数组
		// 同样 吧这个数组中单独的那个数放在 yp 中
			*yp ^= a[i];
		}
	}
	// 至此 两个不相同的数已经通过指针被放在了 xp 和 yp 中,
	return 0;// 表示运算成功
}

int main1(){
	int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 45 };
	int num = sizeof(a) / sizeof(a[0]);
	// 在a里找(a里有num个元素), 还得把找到的值放在x, y中最终要通过找x, y 中的值 => &x,&y
	int x, y;
	if (FindTwoData(a, num, &x, &y) == 0){// 返回值等于0 找成功了
		printf("find success: %d, %d\n", x, y);

	}
	system("pause");
	return 0;
}

//2.喝汽水，1瓶汽水1元，2个空瓶可以换一瓶汽水，
//给20元，可以喝多少汽水。
//编程实现。

// 思路: 
// 1. 至少能喝20瓶, 至少有20个空瓶子
// 2. 转换为我有20个空瓶子, 我还能喝多少瓶
// 3. 只要我手里有 >1 个空瓶子, 我就可以一直喝, 也就是可以一直喝
// 4. 手里面的瓶子数, 是有两种情况的, 一个是奇数个瓶子, 一个是偶数个瓶子
// 问 假如我当前有num个瓶子, 我能喝多少?
// 5. 奇数, 我能喝 num/2 瓶, 我还剩下 num/2+1 个空瓶子
// 6. 偶数, 我能喝 num/2 瓶, 我还剩下 num/2+0 个空瓶子
// 7. 结论: 我能喝 num/2 瓶, 我还剩下 num/2+num%2 个空瓶子

//return : total drink
//money : 钱数
int DrinkWater(int money)
{
	int total = money;// 至少
	int empty = money;// 至少

	while (empty > 1){
		total += empty / 2;// 每次都能喝
		empty = empty / 2 + empty % 2;// 剩下的空瓶子
	}
	printf("empty: %d\n", empty);// empty 不可能为 0
	return total;
	//return total + 1; //可以向老板借一个空瓶子，最后喝完，再还给他。
}

void Reverse(char *start, char *end)
{
	assert(start);
	assert(end);
	while (start < end){
		*start ^= *end;
		*end ^= *start;
		*start ^= *end;
		start++, end--;
	}
}
int main(){
	int money = 20;
	int total = DrinkWater(money);
	printf("total: %d\n", total);// 最终手上有 1 个空瓶子 喝了39瓶

	system("pause");
	return 0;
}